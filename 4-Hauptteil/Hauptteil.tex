% !TEX root = ../Masterarbeit.tex
\chapter{Hauptteil}

\input{4-Hauptteil/Design-Patterns.tex}

\pagebreak

\input{4-Hauptteil/Concurrency-Modelle.tex}

\pagebreak

\section{Reaktive Programmierung}
Reaktive Programmierung, im weiteren Sinne, ist in der Entwicklung von Benutzeroberflächen üblich und verbreitet. Eine Software mit Benutzernutzeroberfläche muss stetig auf Eingaben durch den Benutzer reagieren. Dazu gehören neben Tastatureingaben und Mausklicks auch Cursorbewegungen. Dieser stetige Strom von neuen Informationen und Ereignissen muss verarbeitet werden, ohne dabei die Benutzeroberfläche zu blockieren. Nichts ist ärgerlicher, als eine Software, die nach einem Klick auf einen Button nicht reagiert bis der Vorgang abgeschlossen ist. Ebenso verhält sich es mit Serveranwendungen, die auf eine Vielzahl von gleichzeitigen Anfragen reagieren müssen.\\
Zu Beginn der Arbeit wurde bereits die Definition reaktiver Systeme von Harel und Pnueli genannt. Allgemeiner betrachtet bedeutet das englische Wort \textit{reactive} laut dem Merriam-Webster Wörterbuch \enquote{readily responsive to a stimulus}. Demnach ist etwas \textit{reactive}, wenn es bereitwillig auf einen Reiz reagiert. Im Bezug auf Software sind Reize beispielsweise Cursorbewegungen, Mausklicks oder Anfragen. Konkreter formuliert sind diese Reize Ereignisse, die von einer Komponente verarbeitet werden. Folgich ist ein Ereignis (engl. event) ein Signal über eine Zustandsänderung. Eine Komponente sendet ein Ereignis an seine Empfänger. Die reaktive Programmierung beschäftigt sich mit der nebenläufigen und asynchronen Verarbeitung dieser Ereignisse, um die \textit{responsiveness} der Anwendung sicherzustellen~\cite{rappl_introduction_2016}~\cite[S.~4]{carkci_dataflow_2014}~\cite[S.~5]{blackheath_functional_2015}.

\section{Observer-Pattern}
Ein Ereignis (engl. event) ist ein Signal bzw. ein Fakt über eine Zustandsänderung. Eine Komponente emittiert bzw. veröffentlicht ein Ereignis an seine Empfänger bzw. Beobachter. Hierfür nutzt man traditionellerweise das Verhaltensmuster \textit{observer}. Ein Beobachter (engl. observer) hat die Möglichkeit sich für Zustandsänderungen an- und abzumelden.\\
Folgendes Scala Codebeispiel zeigt das Observer-Pattern durch das Trait \textit{EventEmitter} (\ref{lst:lst5}). Beobachter, im Codebeispiel \textit{Observer} genannt, können sich über die Methoden \textit{subscribe} und \textit{unsubscribe} beim \textit{EventEmitter} an- und abmelden. Kommt es zu einer Zustandsänderung kann der \textit{EventEmitter} alle \textit{Observer} durch den Aufruf von \textit{emit} über das Ereignis informieren. Der \textit{EventEmitter} weiß nur, dass die \textit{Observer} die Methode \textit{handle} implementieren, die durch \textit{emit} aufgerufen wird.

\begin{lstlisting}[caption={Codebeispiel für das Observer-Pattern.},label={lst:lst5}]
trait EventEmitter {
  private var observers: Set[Observer] = Set()

  def subscribe(observer: Observer): Unit = observers += observer
  def unsubscribe(observer: Observer): Unit = observers -= observer
  def emit(): Unit = observers.foreach(_.handle(this))
}

trait Observer {
  def handle(emitter: EventEmitter): Unit
}
\end{lstlisting}

\pagebreak

\begin{lstlisting}[caption={Codebeispiel für das Observer-Pattern.},label={lst:lst6}]
class IncrementButton extends EventEmitter {
  private var counter = 0

  def getCount = counter
  def clicked(): Unit = {
    counter += 1
    emit()
  }
}

class IncrementLogger(button: IncrementButton) extends Observer {
  button.subscribe(this)

  def handle(emitter: EventEmitter): Unit = println(s"new value \${button.count}")
}

val button = new IncrementButton()
val logger = new IncrementLogger(button)

button.clicked() // prints: new value 1
button.clicked() // prints: new value 2
button.clicked() // prints: new value 3
button.clicked() // prints: new value 4
\end{lstlisting}

\subsection{Observables}
%TODO Reactive extensions & Observable 
%TODO Deprecating the Observer Pattern
%TODO Erik Meijer Talk about What is reactive?
%TODO Lesli Lamport We should use mathematics!
%TODO Rx are libraries for asynchronous and therefore reactive programming.

\pagebreak

\section{Reactive Design Patterns}
\subsection{Single Responsibility Pattern}
\subsection{Idempotent Receiver}
\subsection{Reactive Streams}
\subsection{Circuit Breaker}
% Enterprise Integration Patterns: Message, Message Channel, Event Message, Event-Driven Consumer
